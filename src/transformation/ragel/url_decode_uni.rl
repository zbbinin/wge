/**
 * Copyright (c) 2024-2025 Stone Rhino and contributors.
 *
 * MIT License (http://opensource.org/licenses/MIT)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#pragma once

#include <string>
#include <string_view>
#include <unordered_map>

#include "hex_decode.h"

%%{
  machine url_decode_uni;
  
  action skip {}

  action exec_transformation { 
    result.resize(input.size());
    r = result.data();
    if(ts > input.data()){
      memcpy(r, input.data(), ts - input.data());
      r += ts - input.data();
    }
    p = ts;
    fhold;
    fgoto transformation;
  }

  action decode_hex {
    std::string decode;
    if(hexDecode({ts + 1, 2},decode) && !decode.empty()){
      *r++ = decode.front();
    }
  }

  action decode_unicode {
    std::string decode;
    if(hexDecode({ts + 2, 4},decode) && decode.size() == 2){
      unsigned short value = static_cast<unsigned char>(decode[0]) << 8 | static_cast<unsigned char>(decode[1]);
      
      // Find the corresponding character in the unicode map
      // TODO(zhouyu 2025-05-21): The current implementation only supports 20127 codepage, 
      // it's ingnore the configuration that specifyed by SecUnicodeMapFile directive.
      // Please support other unicode maps in the future.
      auto it = unicode_map_20127.find(value);
      if(it != unicode_map_20127.end()) {
        value = it->second;
      }

      // Convert to Unicode
      if(value < 0x80) {
        // 1 byte
        *r++ = static_cast<char>(value);
      } else if(value < 0x800) {
        // 2 bytes
        *r++ = static_cast<char>(0xc0 | (value >> 6));
        *r++ = static_cast<char>(0x80 | (value & 0x3f));
      } else if(value < 0x10000) {
        // Surrogate pairs
        *r++ = static_cast<char>(0xe0 | (value >> 12));
        *r++ = static_cast<char>(0x80 | ((value >> 6) & 0x3f));
        *r++ = static_cast<char>(0x80 | (value & 0x3f));
      }
    }
  }

  HEX = [0-9a-fA-F];

  # prescan
  main := |*
    '+' => exec_transformation;
    '%' HEX HEX => exec_transformation;
    '%' 'u' HEX HEX HEX HEX => exec_transformation;
    any => skip;
  *|;
  
  transformation := |*
    '+' => { *r++ = ' '; };
    '%' HEX HEX => decode_hex;
    '%' 'u' HEX HEX HEX HEX => decode_unicode;
    any => { *r++ = fc; };
  *|;
}%%

%% write data;

static const std::unordered_map<int, char> unicode_map_20127 = {
  {0x00a0, 0x20}, {0x00a1, 0x21}, {0x00a2, 0x63}, {0x00a4, 0x24}, {0x00a5, 0x59},
  {0x00a6, 0x7c}, {0x00a9, 0x43}, {0x00aa, 0x61}, {0x00ab, 0x3c}, {0x00ad, 0x2d},
  {0x00ae, 0x52}, {0x00b2, 0x32}, {0x00b3, 0x33}, {0x00b7, 0x2e}, {0x00b8, 0x2c},
  {0x00b9, 0x31}, {0x00ba, 0x6f}, {0x00bb, 0x3e}, {0x00c0, 0x41}, {0x00c1, 0x41},
  {0x00c2, 0x41}, {0x00c3, 0x41}, {0x00c4, 0x41}, {0x00c5, 0x41}, {0x00c6, 0x41},
  {0x00c7, 0x43}, {0x00c8, 0x45}, {0x00c9, 0x45}, {0x00ca, 0x45}, {0x00cb, 0x45},
  {0x00cc, 0x49}, {0x00cd, 0x49}, {0x00ce, 0x49}, {0x00cf, 0x49}, {0x00d0, 0x44},
  {0x00d1, 0x4e}, {0x00d2, 0x4f}, {0x00d3, 0x4f}, {0x00d4, 0x4f}, {0x00d5, 0x4f},
  {0x00d6, 0x4f}, {0x00d8, 0x4f}, {0x00d9, 0x55}, {0x00da, 0x55}, {0x00db, 0x55},
  {0x00dc, 0x55}, {0x00dd, 0x59}, {0x00e0, 0x61}, {0x00e1, 0x61}, {0x00e2, 0x61},
  {0x00e3, 0x61}, {0x00e4, 0x61}, {0x00e5, 0x61}, {0x00e6, 0x61}, {0x00e7, 0x63},
  {0x00e8, 0x65}, {0x00e9, 0x65}, {0x00ea, 0x65}, {0x00eb, 0x65}, {0x00ec, 0x69},
  {0x00ed, 0x69}, {0x00ee, 0x69}, {0x00ef, 0x69}, {0x00f1, 0x6e}, {0x00f2, 0x6f},
  {0x00f3, 0x6f}, {0x00f4, 0x6f}, {0x00f5, 0x6f}, {0x00f6, 0x6f}, {0x00f8, 0x6f},
  {0x00f9, 0x75}, {0x00fa, 0x75}, {0x00fb, 0x75}, {0x00fc, 0x75}, {0x00fd, 0x79},
  {0x00ff, 0x79}, {0x0100, 0x41}, {0x0101, 0x61}, {0x0102, 0x41}, {0x0103, 0x61},
  {0x0104, 0x41}, {0x0105, 0x61}, {0x0106, 0x43}, {0x0107, 0x63}, {0x0108, 0x43},
  {0x0109, 0x63}, {0x010a, 0x43}, {0x010b, 0x63}, {0x010c, 0x43}, {0x010d, 0x63},
  {0x010e, 0x44}, {0x010f, 0x64}, {0x0110, 0x44}, {0x0111, 0x64}, {0x0112, 0x45},
  {0x0113, 0x65}, {0x0114, 0x45}, {0x0115, 0x65}, {0x0116, 0x45}, {0x0117, 0x65},
  {0x0118, 0x45}, {0x0119, 0x65}, {0x011a, 0x45}, {0x011b, 0x65}, {0x011c, 0x47},
  {0x011d, 0x67}, {0x011e, 0x47}, {0x011f, 0x67}, {0x0120, 0x47}, {0x0121, 0x67},
  {0x0122, 0x47}, {0x0123, 0x67}, {0x0124, 0x48}, {0x0125, 0x68}, {0x0126, 0x48},
  {0x0127, 0x68}, {0x0128, 0x49}, {0x0129, 0x69}, {0x012a, 0x49}, {0x012b, 0x69},
  {0x012c, 0x49}, {0x012d, 0x69}, {0x012e, 0x49}, {0x012f, 0x69}, {0x0130, 0x49},
  {0x0131, 0x69}, {0x0134, 0x4a}, {0x0135, 0x6a}, {0x0136, 0x4b}, {0x0137, 0x6b},
  {0x0139, 0x4c}, {0x013a, 0x6c}, {0x013b, 0x4c}, {0x013c, 0x6c}, {0x013d, 0x4c},
  {0x013e, 0x6c}, {0x0141, 0x4c}, {0x0142, 0x6c}, {0x0143, 0x4e}, {0x0144, 0x6e},
  {0x0145, 0x4e}, {0x0146, 0x6e}, {0x0147, 0x4e}, {0x0148, 0x6e}, {0x014c, 0x4f},
  {0x014d, 0x6f}, {0x014e, 0x4f}, {0x014f, 0x6f}, {0x0150, 0x4f}, {0x0151, 0x6f},
  {0x0152, 0x4f}, {0x0153, 0x6f}, {0x0154, 0x52}, {0x0155, 0x72}, {0x0156, 0x52},
  {0x0157, 0x72}, {0x0158, 0x52}, {0x0159, 0x72}, {0x015a, 0x53}, {0x015b, 0x73},
  {0x015c, 0x53}, {0x015d, 0x73}, {0x015e, 0x53}, {0x015f, 0x73}, {0x0160, 0x53},
  {0x0161, 0x73}, {0x0162, 0x54}, {0x0163, 0x74}, {0x0164, 0x54}, {0x0165, 0x74},
  {0x0166, 0x54}, {0x0167, 0x74}, {0x0168, 0x55}, {0x0169, 0x75}, {0x016a, 0x55},
  {0x016b, 0x75}, {0x016c, 0x55}, {0x016d, 0x75}, {0x016e, 0x55}, {0x016f, 0x75},
  {0x0170, 0x55}, {0x0171, 0x75}, {0x0172, 0x55}, {0x0173, 0x75}, {0x0174, 0x57},
  {0x0175, 0x77}, {0x0176, 0x59}, {0x0177, 0x79}, {0x0178, 0x59}, {0x0179, 0x5a},
  {0x017b, 0x5a}, {0x017c, 0x7a}, {0x017d, 0x5a}, {0x017e, 0x7a}, {0x0180, 0x62},
  {0x0189, 0x44}, {0x0191, 0x46}, {0x0192, 0x66}, {0x0197, 0x49}, {0x019a, 0x6c},
  {0x019f, 0x4f}, {0x01a0, 0x4f}, {0x01a1, 0x6f}, {0x01ab, 0x74}, {0x01ae, 0x54},
  {0x01af, 0x55}, {0x01b0, 0x75}, {0x01b6, 0x7a}, {0x01cd, 0x41}, {0x01ce, 0x61},
  {0x01cf, 0x49}, {0x01d0, 0x69}, {0x01d1, 0x4f}, {0x01d2, 0x6f}, {0x01d3, 0x55},
  {0x01d4, 0x75}, {0x01d5, 0x55}, {0x01d6, 0x75}, {0x01d7, 0x55}, {0x01d8, 0x75},
  {0x01d9, 0x55}, {0x01da, 0x75}, {0x01db, 0x55}, {0x01dc, 0x75}, {0x01de, 0x41},
  {0x01df, 0x61}, {0x01e4, 0x47}, {0x01e5, 0x67}, {0x01e6, 0x47}, {0x01e7, 0x67},
  {0x01e8, 0x4b}, {0x01e9, 0x6b}, {0x01ea, 0x4f}, {0x01eb, 0x6f}, {0x01ec, 0x4f},
  {0x01ed, 0x6f}, {0x01f0, 0x6a}, {0x0261, 0x67}, {0x02b9, 0x27}, {0x02ba, 0x22},
  {0x02bc, 0x27}, {0x02c4, 0x5e}, {0x02c6, 0x5e}, {0x02c8, 0x27}, {0x02cb, 0x60},
  {0x02cd, 0x5f}, {0x02dc, 0x7e}, {0x0300, 0x60}, {0x0302, 0x5e}, {0x0303, 0x7e},
  {0x030e, 0x22}, {0x0331, 0x5f}, {0x0332, 0x5f}, {0x2000, 0x20}, {0x2001, 0x20},
  {0x2002, 0x20}, {0x2003, 0x20}, {0x2004, 0x20}, {0x2005, 0x20}, {0x2006, 0x20},
  {0x2010, 0x2d}, {0x2011, 0x2d}, {0x2013, 0x2d}, {0x2014, 0x2d}, {0x2018, 0x27},
  {0x2019, 0x27}, {0x201a, 0x2c}, {0x201c, 0x22}, {0x201d, 0x22}, {0x201e, 0x22},
  {0x2022, 0x2e}, {0x2026, 0x2e}, {0x2032, 0x27}, {0x2035, 0x60}, {0x2039, 0x3c},
  {0x203a, 0x3e}, {0x2122, 0x54}, {0xff01, 0x21}, {0xff02, 0x22}, {0xff03, 0x23},
  {0xff04, 0x24}, {0xff05, 0x25}, {0xff06, 0x26}, {0xff07, 0x27}, {0xff08, 0x28},
  {0xff09, 0x29}, {0xff0a, 0x2a}, {0xff0b, 0x2b}, {0xff0c, 0x2c}, {0xff0d, 0x2d},
  {0xff0e, 0x2e}, {0xff0f, 0x2f}, {0xff10, 0x30}, {0xff11, 0x31}, {0xff12, 0x32},
  {0xff13, 0x33}, {0xff14, 0x34}, {0xff15, 0x35}, {0xff16, 0x36}, {0xff17, 0x37},
  {0xff18, 0x38}, {0xff19, 0x39}, {0xff1a, 0x3a}, {0xff1b, 0x3b}, {0xff1c, 0x3c},
  {0xff1d, 0x3d}, {0xff1e, 0x3e}, {0xff20, 0x40}, {0xff21, 0x41}, {0xff22, 0x42},
  {0xff23, 0x43}, {0xff24, 0x44}, {0xff25, 0x45}, {0xff26, 0x46}, {0xff27, 0x47},
  {0xff28, 0x48}, {0xff29, 0x49}, {0xff2a, 0x4a}, {0xff2b, 0x4b}, {0xff2c, 0x4c},
  {0xff2d, 0x4d}, {0xff2e, 0x4e}, {0xff2f, 0x4f}, {0xff30, 0x50}, {0xff31, 0x51},
  {0xff32, 0x52}, {0xff33, 0x53}, {0xff34, 0x54}, {0xff35, 0x55}, {0xff36, 0x56},
  {0xff37, 0x57}, {0xff38, 0x58}, {0xff39, 0x59}, {0xff3a, 0x5a}, {0xff3b, 0x5b},
  {0xff3c, 0x5c}, {0xff3d, 0x5d}, {0xff3e, 0x5e}, {0xff3f, 0x5f}, {0xff40, 0x60},
  {0xff41, 0x61}, {0xff42, 0x62}, {0xff43, 0x63}, {0xff44, 0x64}, {0xff45, 0x65},
  {0xff46, 0x66}, {0xff47, 0x67}, {0xff48, 0x68}, {0xff49, 0x69}, {0xff4a, 0x6a},
  {0xff4b, 0x6b}, {0xff4c, 0x6c}, {0xff4d, 0x6d}, {0xff4e, 0x6e}, {0xff4f, 0x6f},
  {0xff50, 0x70}, {0xff51, 0x71}, {0xff52, 0x72}, {0xff53, 0x73}, {0xff54, 0x74},
  {0xff55, 0x75}, {0xff56, 0x76}, {0xff57, 0x77}, {0xff58, 0x78}, {0xff59, 0x79},
  {0xff5a, 0x7a}, {0xff5b, 0x7b}, {0xff5c, 0x7c}, {0xff5d, 0x7d}, {0xff5e, 0x7e}
};

static bool urlDecodeUni(std::string_view input, std::string& result) {
  result.clear();
  char* r = nullptr;

  const char* p = input.data();
  const char* pe = p + input.size();
  const char* eof = pe;
  const char* ts, *te;
  int cs,act;

  %% write init;
  %% write exec;

  if(r) {
    result.resize(r - result.data());
    return true;
  }

  return false;
}